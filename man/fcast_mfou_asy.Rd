% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecasting.R
\name{cov_dt_mfou_asy}
\alias{cov_dt_mfou_asy}
\alias{cov_jhdt_mfou_asy}
\alias{fcast_point_mfou_asy}
\alias{fcast_se_mfou}
\title{Forecasting the slow mfOU using Gaussian conditioning}
\usage{
cov_dt_mfou_asy(n, nu, H, rho, eta, cov0, delta)

cov_jhdt_mfou_asy(n, h, nu, H, rho, eta, cov0, delta, j)

fcast_point_mfou_asy(
  my,
  h,
  nu,
  H,
  rho,
  eta,
  cov0,
  delta,
  mu = NULL,
  plot = FALSE
)

fcast_se_mfou(n, h, nu, H, rho, eta, cov0, delta)
}
\arguments{
\item{n}{Integer. Length of the time series.}

\item{nu}{Vector of diffusion coefficients.}

\item{H}{Vector of Hurst coefficients.}

\item{rho}{Symmetric matrix of instantaneous correlation coefficients.}

\item{eta}{Antisymmetric matrix of asymmetry coefficients.}

\item{cov0}{Symmetric matrix of lag 0 covariances.}

\item{delta}{Time step between consecutive observations in the time series y (e.g., 1/252 for daily data if time is in years).}

\item{h}{Integer. Forecast horizon (e.g. 1, 5, 10 steps ahead).}

\item{j}{Component of the system. Integer between 1 and \eqn{d} or column name.}

\item{my}{Numeric matrix containing the time series in its columns.}

\item{mu}{Vector of long term means. Default is NULL, in which case it is computed as sample average.}

\item{plot}{Logical. Default is FALSE. If TRUE, a panel of plots will exhibit
the weights of the linear combination.}
}
\value{
Numeric matrices.
}
\description{
Using a standard result for Gaussian random vectors, these functions allow
us to compute point forecasts and associated standard errors in the framework
of the slow multivariate fractional Ornstein-Uhlenbeck process of dimension \eqn{d}.
This process is constructed by leveraging the small mean reversion coefficient
asymptotic result of the cross-covariance function .

Given that the vector that we want to predict, \eqn{X:=Y_{(n+h)\Delta}\in\mathbb{R}^d}, and the
history of information, \eqn{Y:=\left(Y_{n\Delta},\dots, Y_{\Delta}\right)\in\mathbb{R}^{d\times n}},
are jointly Gaussian, we use that:

\deqn{\mu_{X|Y}=\mu_X+\Sigma_{XY}\Sigma_{YY}^{-1}\left(Y-\mu_Y\right),}
\deqn{\Sigma_{XX|Y}=\Sigma_{XX}-\Sigma_{XY}\Sigma_{YY}^{-1}\Sigma_{XY}^T,}
where we used the notation \eqn{\mu_Z=\mathbb{E}(Z)} and
\eqn{\Sigma_{ZU} = \mathbb{E}((Z-\mu_Z)(U-\mu_U)^T)}.
\itemize{
\item \code{cov_jhdt_mfou_asy} calculates the matrix \eqn{\Sigma_{XY}} described above;
\item \code{cov_dt_mfou_asy} calculates the matrix \eqn{\Sigma_{YY}} described above;
\item \code{cov_0_mfou_asy} calculates the matrix \eqn{\Sigma_{XX}} described above;
\item \code{fcast_point_mfou_asy} calculates point forecasts, i.e. the vector \eqn{\mu_{X|Y}} described above;
\item \code{fcast_se_mfou_asy} calculates standard errors of the forecasts, i.e. the matrix \eqn{\Sigma_{XX|Y}} described above;
}

The functions \code{fcast_point_mfou_asy} and \code{fcast_se_mfou_asy} are not efficient in
rolling window applications with fixed parameters. In which case,
efficiency gains could often be obtained by avoiding redundant matrix operations.
}
