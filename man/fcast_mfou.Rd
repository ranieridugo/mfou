% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecasting.R
\name{cov_dt_mfou}
\alias{cov_dt_mfou}
\alias{cov_dt_fou}
\alias{cov_jhdt_mfou}
\alias{cov_0_mfou}
\alias{fcast_point_mfou}
\alias{fcast_se_mfou}
\title{Forecasting the mfOU using Gaussian conditioning}
\usage{
cov_dt_mfou(n, a, nu, H, rho, eta, delta)

cov_dt_fou(n, a, nu, H, delta)

cov_jhdt_mfou(n, h, a, nu, H, rho, eta, delta, j)

cov_0_mfou(a, nu, H, rho, eta)

fcast_point_mfou(my, h, a, nu, H, rho, eta, delta, mu = NULL, plot = FALSE)

fcast_se_mfou(n, h, nu, H, rho, eta, cov0, delta)
}
\arguments{
\item{n}{Integer. Length of the time series.}

\item{a}{Vector of speed of mean reversion coefficients.}

\item{nu}{Vector of diffusion coefficients.}

\item{H}{Vector of Hurst coefficients.}

\item{rho}{Symmetric matrix of instantaneous correlation coefficients.}

\item{eta}{Antisymmetric matrix of asymmetry coefficients.}

\item{delta}{Time step between consecutive observations in the time series y (e.g., 1/252 for daily data if time is in years).}

\item{h}{Integer. Forecast horizon (e.g. 1, 5, 10 steps ahead).}

\item{j}{Component of the system. Integer between 1 and \eqn{d} or column name.}

\item{my}{Numeric matrix containing the time series in its columns.}

\item{mu}{Vector of long term means. Default is NULL, in which case it is computed as sample average.}

\item{plot}{Logical. Default is FALSE. If TRUE, a panel of plots will exhibit
the weights of the linear combination.}
}
\value{
Numeric matrices.
}
\description{
Using a standard result for Gaussian random vectors, these functions allow
us to compute point forecasts and associated standard errors in the framework
of the multivariate fractional Ornstein-Uhlenbeck process of dimension \eqn{d}.

Given that the vector that we want to predict, \eqn{X:=Y_{(n+h)\Delta}\in\mathbb{R}^d}, and the
history of information, \eqn{Y:=\left(Y_{n\Delta},\dots, Y_{\Delta}\right)\in\mathbb{R}^{d\times n}},
are jointly Gaussian, we use that:

\deqn{\mu_{X|Y}=\mu_X+\Sigma_{XY}\Sigma_{YY}^{-1}\left(Y-\mu_Y\right),}
\deqn{\Sigma_{XX|Y}=\Sigma_{XX}-\Sigma_{XY}\Sigma_{YY}^{-1}\Sigma_{XY}^T,}
where we used the notation \eqn{\mu_Z=\mathbb{E}(Z)} and
\eqn{\Sigma_{ZU} = \mathbb{E}((Z-\mu_Z)(U-\mu_U)^T)}.
\itemize{
\item \code{cov_jhdt_mfou} calculates the matrix \eqn{\Sigma_{XY}} described above;
\item \code{cov_dt_mfou} calculates the matrix \eqn{\Sigma_{YY}} described above;
\item \code{cov_0_mfou} calculates the matrix \eqn{\Sigma_{XX}} described above;
\item \code{fcast_point_mfou} calculates point forecasts, i.e. the vector \eqn{\mu_{X|Y}} described above;
\item \code{fcast_se_mfou} calculates standard errors of the forecasts, i.e. the matrix \eqn{\Sigma_{XX|Y}} described above;
}

The functions \code{fcast_point_mfou} and \code{fcast_se_mfou} are not efficient in
rolling window applications with fixed parameters. In which case,
efficiency gains could often be obtained by avoiding redundant matrix operations.
}
\examples{
# generating the data
n = 1000
delta = 1/252;
H = c(0.4, 0.2, 0.6)
rho = matrix(c(1, .2, .7, 0.2, 1, 0.6, 0.7, 0.6, 1), nc = 3)
eta = matrix(c(0, .15, 0, - 0.15, 0, - 0.02, 0, 0.02, 0), nc = 3)
a = c(1, 2, 0.05); nu = c(8, 2, 3); mu = c(0, 0, 0)
mfou = sim_mfou_exa(n, H, rho, eta, a, nu, mu, delta)

# rolling window forecast using n observations at a time
d = ncol(mfou)
n = 512; h = 1
fcast = cbind(mfou, matrix(NA, nrow = nrow(mfou), ncol = d))
colnames(fcast) <- c(paste0("x_", 1 : d), paste0("f_", 1 : d))
syy = cov_dt_mfou(n = n, a = a, nu = nu, H = H, rho = rho, eta = eta, delta = delta)
sxy = t(sapply(X = 1 : d, FUN = cov_jhdt_mfou,
               n = n, h = h, a = a, nu = nu, H = H, rho = rho, eta = eta, delta = delta))
syy_inv = solve(syy)
w = sxy \%*\% syy_inv
for(f in (n + 1) : nrow(fcast)) {
  tmp = t(fcast[(f - n) : (f - 1), 1 : d])
  fcast[f, (d + 1) : (2 * d)] =
    w \%*\% c(tmp)
}

# plot
fcast |>
  as.data.frame() |>
  dplyr::mutate(t = dplyr::row_number()) |>
  tidyr::pivot_longer(!t,
    values_to = "val",
    names_to = c("s", "d"),
    names_pattern = "([^_]+)_([^_]+)") |>
  dplyr::filter(val != 0) |>
  dplyr::mutate(
    s = factor(s, levels = c("x", "f"))  # ensures 'f' is drawn *after* 'x') |>
  ggplot2::ggplot(ggplot2::aes(x = t, y = val, col = s)) +
  ggplot2::geom_line() +
  ggplot2::facet_wrap(~ d, nrow = 3) +
  ggplot2::theme_minimal()
}
\references{
https://en.wikipedia.org/wiki/Multivariate_normal_distribution
}
