% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim.R
\name{sim_mfou_app}
\alias{sim_mfou_app}
\alias{sim_mfou_exa}
\alias{sim_fou_exa}
\title{Simulation of the mfOU process}
\usage{
sim_mfou_app(n, H, rho, eta, a, nu, mu, delta = 1, m = 1)

sim_mfou_exa(n, H, rho, eta, a, nu, mu, delta, m = 1)

sim_fou_exa(n, H, a, nu, mu, delta, m = 1)
}
\arguments{
\item{n}{Length of the time series.}

\item{H}{Vector of Hurst coefficients.}

\item{rho}{Symmetric matrix of instantaneous correlation coefficients.}

\item{eta}{Antisymmetric matrix of asymmetry coefficients.}

\item{a}{Vector of speed of mean reversion coefficients.}

\item{nu}{Vector of diffusion coefficients.}

\item{mu}{Vector of long-term means.}

\item{delta}{Time step between consecutive observations in the time series y (e.g., 1/252 for daily data if time is in years).}

\item{m}{Number of simulations.}
}
\value{
List of m numeric matrices of size n x d.
}
\description{
These functions simulate the multivariate fractional Ornstein-Uhlenbeck process of
dimension \eqn{d}.
\itemize{
\item \code{sim_mfou_app} relies on a combination of circulant embedding and the Euler-Maruyama scheme,
and due to the latter step is approximate;
\item \code{sim_mfou_exa} uses the Cholesky decomposition of the covariance matrix,
and is therefore exact. This methodology might lead to numerical instability
for long series or certain parameters' combinations.
}

The input parameters \eqn{\rho}, \eqn{\eta}, and \eqn{H} must satisfy the condition
for the existence of the covariance matrix of the underlying mfBm, which is verified
at the beginning.
}
\examples{
# parameters
m = 3; delta = 1/252; n = 4 / delta
H = c(0.1, 0.2, 0.3)
rho = matrix(c(1, .3, .4, 0.3, 1, 0.5, 0.4, 0.5, 1), nc = 3)
eta = matrix(c(0, .02, 0, - 0.02, 0, - 0.01, 0, 0.01, 0), nc = 3)
a = c(1, 2, 3); nu = c(1, 2, 3); mu = c(0, 0, 0)

# we simulate lambda observations for each step of size delta
# so to reduce the discretization error of the Euler-Maruyama scheme
lambda = 24

# simulation
tmp = sim_mfou_app(n * lambda, delta / lambda , H, rho, eta, a, nu, mu, m)

# retaining observations at a distance delta and discarding
# the first n/4 observations to approach the stationary distribution
mfou = lapply(X = tmp, FUN = function(x) x[seq(lambda, nrow(x), by = lambda), ][(n / 4 + 1) : n, ])

# exact simulation
sim_mfou_exa(n, H, rho, eta, a, nu, mu, delta)
}
